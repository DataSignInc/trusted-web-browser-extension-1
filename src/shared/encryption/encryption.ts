import { PrivateJwk, PublicJwk } from "@/types";
import { ec as EC } from "elliptic";
import { convertEcKeyPairToJwk } from "../keys";
import { base64url } from "jose";
import b64url from "base64url";
import { resolvePublicJwkFromDID } from "../did/siop";

const ec = new EC("secp256k1");

const ENCRYPTION_ALGORITHM = "AES-GCM";
// The length of an authentication tag in ECDH-ES is 128 bits == 16 bytes.
const TAG_BIT_LENGTH = 128;
// The length of an initialization vector in AES-GCM is 96 bits == 12 bytes.
const IV_LENGTH = 96 / 8;

export const encrypt = async (
  content: string,
  recipient: EC.KeyPair | PublicJwk | string
) => {
  const publicKey = await convertAnythingToPublicKeyPair(recipient);

  const ephemeralKeyPair = ec.genKeyPair();
  // `d` in JWK shouldn't be sent to the receiver because it reveals the private key value.
  const { d, ...epkPublic } = convertEcKeyPairToJwk(ephemeralKeyPair);

  // this data is for telling the receiver how to decrypt this JWE.
  const protectedHeader = {
    // Key agreement scheme
    alg: "ECDH-ES",
    // Symmetric encryption algorithm
    enc: "A256GCM",
    // A ECC public key which corresponds to the private key used by the sender to generate encryption key.
    epk: epkPublic,
  };

  // Derive (do key agreement) an encryption key with epk and the public key of the receiver.
  const symmetricKey = ephemeralKeyPair.derive(publicKey);
  // We need the second parmeter of toString() (the length paramter). Otherwise we sometime get invalid shorter keys.
  const symmetricKeyBuffer = Buffer.from(symmetricKey.toString(16, 32), "hex");
  // cek is the abbreviation for "Content Encryption Key"
  const cek = await crypto.subtle.importKey(
    "raw",
    symmetricKeyBuffer,
    ENCRYPTION_ALGORITHM,
    false,
    ["encrypt"]
  );

  // Generate initialization vector.
  // We need it to ensure the JWE cannot be used for replay attack.
  // iv's randomness allows JWE to be different values even if we encrypt the same data more than twice.
  const iv = new Uint8Array(IV_LENGTH);
  crypto.getRandomValues(iv);

  // AES-GCM uses protectedHeader to generate authentication tag, which let protectedHeader to be tamper-proofing.
  const aesGcmParams = makeAesGcmParameters(protectedHeader, iv);

  // encrypt the content.
  const encoder = new TextEncoder();
  const plaintext = encoder.encode(content);
  const encrypted = await crypto.subtle.encrypt(aesGcmParams, cek, plaintext);
  const ciphertextWithTag = Buffer.from(encrypted);

  // Split encrypted data to extract the authencation tag.
  // Authentication tag is the last `TAG_BIT_LENGTH` bits of AES-GCM-encrypted data.
  const tagByteOffset = -TAG_BIT_LENGTH / 8;
  const ciphertextBuffer = ciphertextWithTag.slice(0, tagByteOffset);
  const tagBuffer = ciphertextWithTag.slice(tagByteOffset);

  const protectedHeaderBuffer = Buffer.from(JSON.stringify(protectedHeader));

  // Here we serialize data with "JWE Compact Serialization" (in RFC 7516), with which the output is not JSON.
  // We omit "JWE Encrypted Key" because we use the Direct Key Agreement mode of
  // ECDH-ES as specified in the section 4.6 of RFC 7518 (the JWA spec).
  return concatBuffersAsBase64urls([
    protectedHeaderBuffer,
    Buffer.from(iv),
    ciphertextBuffer,
    tagBuffer,
  ]);
};

export const decrypt = async (
  compactJwe: string,
  recipientKeyPair: EC.KeyPair | PrivateJwk
) => {
  const [protectedHeader, iv, ciphertext, tag] = splitCompactJWE(compactJwe);
  // ciphertext and tag are splitted by the sender to conform to the JWE spec.
  // Originally they are the one output of the AES-GCM `encrypt()` function.
  // We here join them again to pass it later to the `decrypt()` function.
  const body = Buffer.concat([ciphertext, tag]);

  // This is the "ep"hemeral "k"ey generated by the sender in JWK format.
  const epk = protectedHeader.epk;
  const epkPublicKey = convertPublicJwkToKey(epk);

  // This is receiver's key pair. It must correspond to receiver's public key the sender used to generate cek (do key agreement).
  const myKeyPair =
    "kty" in recipientKeyPair
      ? convertPrivateJwkToKeyPair(recipientKeyPair)
      : recipientKeyPair;

  // Derive (do key agreement) an decryption key. It must be identical to `cek` the sender used.
  const symmetricKey = myKeyPair.derive(epkPublicKey.getPublic());
  // We need the second parmeter of toString() (the length paramter). Otherwise we sometime get invalid shorter keys.
  const symmetricKeyBuffer = Buffer.from(symmetricKey.toString(16, 32), "hex");
  const cek = await crypto.subtle.importKey(
    "raw",
    symmetricKeyBuffer,
    ENCRYPTION_ALGORITHM,
    false,
    ["decrypt"]
  );

  // We can ensure protectedHeader is not tampered in the AES-GCM encryption algorithm by passing it as a parameter.
  const aesGcmParams = makeAesGcmParameters(protectedHeader, iv);
  // Decrypt the content. It also does the verification of protectedHeader.
  const decrypted: ArrayBuffer = await crypto.subtle.decrypt(
    aesGcmParams,
    cek,
    body
  );
  const decryptedBuffer: Buffer = Buffer.from(decrypted);
  // Decode the decrypted content.
  // TODO: We assume it is in utf-8 encoding but it can be wrong as the number of use cases grows.
  return new TextDecoder("utf-8").decode(decryptedBuffer);
};

const makeAesGcmParameters = (additionalData: any, iv: ArrayBuffer) => {
  const aesGcmParameters = {
    name: ENCRYPTION_ALGORITHM,
    iv: iv,
    additionalData: encodeAdditionalData(additionalData),
  };
  return aesGcmParameters;
};

const encodeAdditionalData = (data: any) => {
  // encode additionalData in ASCII encoding as per Section 5.1 of RFC 7516 (the JWE spec).
  // This encoding of additionalData is used only for generating a tamper-proofing authentication tag.
  return (new TextEncoder()).encode(JSON.stringify(data));
};

const concatBuffersAsBase64urls = (buffers: Buffer[]) => {
  const texts = buffers.map(base64url.encode);
  return texts.join(".");
};

const splitCompactJWE = (compactJwe: string): [any, Buffer, Buffer, Buffer] => {
  const decoder = new TextDecoder();
  const base64urlArray = compactJwe.split(".");
  const [protectedHeader, iv, ciphertext, tag] = base64urlArray.map((s) =>
    Buffer.from(base64url.decode(s))
  );
  return [JSON.parse(decoder.decode(protectedHeader)), iv, ciphertext, tag];
};

const convertPublicJwkToKey = (jwk: PublicJwk) => {
  const f = (b64url: string) => {
    const ua = base64url.decode(b64url);
    const buf = Buffer.from(ua);
    return buf.toString("hex");
  };

  const pubKey = ec.keyFromPublic({ x: f(jwk.x), y: f(jwk.y!) });
  return pubKey;
};

const convertPrivateJwkToKeyPair = (jwk: PrivateJwk) => {
  const pubKey = ec.keyFromPrivate(b64url.toBuffer(jwk.d));
  return pubKey;
};

const convertAnythingToPublicKeyPair = async (
  didOrJwk: EC.KeyPair | PublicJwk | string
) => {
  let publicKey;
  if (typeof didOrJwk === "string") {
    const publicKeyJwk = await resolvePublicJwkFromDID(didOrJwk);
    if (typeof publicKeyJwk !== "undefined") {
      publicKey = convertPublicJwkToKey(publicKeyJwk).getPublic();
    } else {
      throw Error("invalid jwk");
    }
  } else if ("kty" in didOrJwk) {
    publicKey = convertPublicJwkToKey(didOrJwk).getPublic();
  } else {
    publicKey = didOrJwk.getPublic();
  }
  return publicKey;
};
